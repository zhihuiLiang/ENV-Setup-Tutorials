# 8086架构机器汇编语言
可参考[8086CPU常用寄存器](https://blog.csdn.net/weixin_44756457/article/details/104444573#:~:text=%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88Register%EF%BC%89%EF%BC%9ACPU%E5%86%85%E9%83%A8%E7%94%A8%E4%BA%8E%E6%9A%82%E6%97%B6%E5%AD%98%E6%94%BE%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%20%E9%AB%98%E9%80%9F%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83,%E3%80%82%208086%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%E5%8F%AF%E5%88%86%E4%B8%BA8%E4%B8%AA%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%884%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C4%E4%B8%AA%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89%EF%BC%8C1%E4%B8%AA%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C1%E4%B8%AA%E6%8C%87%E4%BB%A4%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%8A4%E4%B8%AA%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82)
## 寄存器
### 通用寄存器
+ 8086CPU都是16位的，`AX`,`BX`,`CX`,`DX`存放一般性数据，被称为通用寄存器
### 8086寻址方式
+ 段地址×16+偏移地址
### 段寄存器
#### `CS`和`IP`寄存器
当8086CPU访问内存时，由`CS`,`DS`,`SS`,`ES`,4个段寄存器提供内存单元的段地址
+ `CS`和`IP`是CPU中两个最关键的寄存器，指示了CPU当前要读取的地址，`CS`为代码段寄存器，`IP`为指令指针寄存器，每读取一条指令IP自动增加
+ 8086CPU不能采用`move`指令去修改`CS`和`IP`的值，需要采用`jmp`跳转指令去改`CS`,`IP`
    + `jmp` 段地址:偏移地址 
    + `jmp` 某一个合法寄存器:用寄存器值去修改`IP`
#### DS和[address]寄存器
执行`move [...]`指令时，8086CPU自动去`DS`中的数据为内存单元的段地址，再加上`[]`中的偏移地址即为操作的内存地址
#### SS和SP寄存器
8086CPU中，有两个寄存器，段寄存器`SS`和寄存器`SP`,栈顶的段地址存在`SS`中，偏移地址存放在`SP`中，任意时刻`SS`:`SP`指向栈顶元素
## 编写程序
汇编语言中，包含两种指令，一种汇编指令，一种伪指令
+ 伪指令
(1)
```
XXX segment
.
.
.
XXX ends
```
(2)`assume`指令为“假设”，假设某一段寄存器和程序中某一个用`segment...ends`定义的段相关联
## Loop指令
采用`loop`指令来实现循环功能，`CX`中存放循环次数
## CALL和RET指令
### `ret`和`retf`
+ `ret`指令用栈中的数据修改`IP`的内容，从而实现近转移
，执行`ret`相当于`pop IP`
+ `retf`指令用栈中的数据，修改`CS`和`IP`的内容，
相对与`pop IP`和`pop CS`
### `call`指令
`call 标号`（将当前`IP`压栈后，转到标号执行指令），相当于
```
push IP
jmp near ptr 标号
## 内中断
对于8086CPU，当CPU内部有下面的情况发生的时候，将产生相应的中断信息。
+ 除法错误
+ 单步执行
+ 执行into指令
+ 执行int指令
## 中断向量表
CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址